## 数据结构绪论

### 数据结构的概念及分类

#### 数据，数据元素，数据对象

1. **数据**：数据是信息的载体，是对客观事物的符号表示，是所有能被输入到计算机中并被计算机识别和处理的符号集合。

2. **数据元素**：数据元素是数据的基本单位。在计算机程序中，数据元素通常被作为一个**整体**进行处理。数据元素又称**元素**，**结点**或**记录**。

3. **数据对象**：数据元素的集合构成数据对象，数据对象通常针对某种特定的应用。（另外，此处的数据对象不是指面向对象思想中的数据对象）。

4. **数据元素可以由若干个数据项构成。数据项又分为组项跟基本项，组项由更小的组项和基本项构成。基本项是具有独立含义的最小标识单位。**

#### 数据结构

1. **数据结构的定义**：数据结构通常指某一数据对象所有元素之间的关系。可以表示为:
  
        数据结构={D，R}， 其中：

        D：表示某一数据对象。R：该集合中所有元素之间关系的有限集合。

数据结构也可指数据元素之间的**逻辑关系** 。可以看作是从具体问题抽象出来的数据模型，其与数据的存储无关。

2. **数据的存储结构**：数据的存储结构是数据的逻辑结构在计算机中的表示方式，它依赖于数据的逻辑结构。作用在数据逻辑结构上的操作的实现依赖于数据的存储结构。

3. **数据的逻辑结构与编程语言无关。数据的逻辑结构通常与选用的编程语言相关。**

#### 数据结构的分类

1. 数据逻辑结构的分类：

数据的逻辑结构分为**线性结构**，**集合结构**，**树形结构**和**图结构**。

        线性结构：数据元素之间是一对一的。典型的如数组。
        集合结构：元素之间无直接关系，或者说元素之间关系为空。
        树形结构：树形结构元素之间是一对多的。典型的如图书馆二叉树。
        图结构：图结构元素之间是多对多的。

2. 数据存储结构的分类：

        数据的存储结构可以分为4类：

        顺序存储，链式存储，索引存储，散列存储（也称哈希存储）。

        顺序存储：顺序存储，顾名思义，就是按照顺序依次存放元素。顺序存储往往需要连续的一段存储单元。采用顺序存储，其逻辑上相邻的元素，物理上也相邻。
        链式存储：链式存储不要求逻辑上相邻的元素物理位置上也相邻。为了表示元素之间的关系，链式存储往往使用指针（C/C++）或者静态链表（无指针的编程语言）来表示元素之间的关系。
        索引存储: 索引存储通过建立索引表来组织所有元素。
        散列存储：散列存储通过散列函数直接将数据记录的关键字映射为该元素的存放地址。

    索引存储跟散列存储都可实现跨存储器的数据存储。

#### 数据类型与抽象数据类型

1. **数据类型**：数据类型指一个值的集合和定义在该集合上的一组操作的总称。
    数据类型可分为： **基本数据类型**和**构造数据类型**。
    
    - **基本数据类型**：基本数据类型可以认为是在某种编程语言中已经定义好的数据类型。以**C++** 语言为例，**C++** 语言提供的基本数据类型有：**整形（int）,浮点型（float），双精度型（double）,字符型（char）** 等等。

    - **构造数据类型**：构造类型，由基本数据类型或者构造数据类型来组成。通常，构造类型往往为了满足实际问题所需要的数据元素类型。在**C**语言中提供**结构**来方便用户自定义构造类型。而在 **C++** 等支持面向对象的编程语言中，除了结构还有以类的方式来自定义数据类型。

2. **抽象数据类型**：抽象数据类型实际上是一种构造类型。它有三个特点：**信息隐蔽** ，**数据封装** ，**使用与实现相分离** 。最典型的数据类型就是面向对象思想中的类。

3. **数据结构与数据类型的异同**：

    - **同**：数据结构与数据类型都具有抽象性。两者并不指一种特定的数据，而是仅仅表示构成某种数据的关系。

    - **异**：数据结构是一种数据的组织和使用形式，通过把数据结构定义为数据类型，才能在计算机上使用。因此，数据类型可以看成是数据结构在计算机上的具体实现。

#### 疑难解答

1. **系统开发和设计时需考虑的数据内容，数据结构，数据流的定义是什么？有何联系？**

        答：系统开发时需要先了解系统输入跟输出的数据，以及中间过程所产生的数据，这些数据即为数据内容。根据数据内容，通过分析，抽象成数据模型，从而形成数据结构。最后，需要在系统中规定这些数据该如何转换，在不同模块或子系统中如何传送，从而形成了数据流。

2. **数据的逻辑结构是否可以独立于数据的存储结构来考虑？反之，数据的存储结构是否独立于数据的逻辑结构来考虑？**

        答：数据的逻辑结构跟存储结构实际反映数据设计的两个阶段，数据的逻辑结构在数据分析时进行，数据的存储结构在数据的设计时进行。换句话来说，数据的存储结构是数据的逻辑结构在计算机上的具体实现。因此，数据的逻辑结构可以独立于数据的存储结构来考虑，也就是，数据的逻辑结构可以不用在具体计算机上去实现。反过来，数据的存储结构不能独立于数据的逻辑结构来考虑，它是数据的逻辑结构在计算机中映像，一种数据的存储结构必然对应该类数据的逻辑结构。

3. **集合结构中的元素之间没有特定的关系，这是否意味着需要借助其他存储结构来表示？**

        答：集合结构往往借助其他存储结构来实现，例如数组，有序链表，数或森林的父指针数组等。

4. **哈希表中的关键码（key）有时被称为关键字或键，可以用数据元素中的一个或多个数据项来定义。那么它是指关键码项还是关键码值？它是否可用于标识一个数据元素？**

        答：关键码指代关键码项还是关键码值需要根据问题的上下文来确定。在讨论关键码的定义或者实现时是指关键码项，在讨论关键码的应用或者使用时是指关键码值。若规定一个数据对象中的所有关键码值互不相等，则关键码可以唯一标识一个数据元素，否则则不能唯一标识一个数据元素。在查找应用中，关键码项称为主关键码，关键码值称为次关键码或辅关键码。

5. **为何在数据结构的课程中不仅要讨论解决各类问题中的典型数据逻辑结构，还需要讨论这些逻辑结构的典型存储结构跟这种数据的相关操作（基本运算）及其实现？**

        答：数据结构分为两种视图——应用视图和实现视图。逻辑结构与用户可见的操作组成应用视图，它是根据应用的需要定义的。而存储结构和相关操作（用户不可见）组成实现视图，它是根据使用环境和性能要求建立的。因此，数据结构课程需要讨论数据的逻辑结构，存储结构跟相关操作和实现。
6 **若逻辑结构相同而存储结构不同的数据结构，是否为同一种数据结构？**

        答：数据结构一般指数据的逻辑结构，因此，只要数据的逻辑结构相同，即使数据的存储结构不相同，也称它们为同一种数据结构。典型的比如顺序表跟链表，显然它们是两种不同的存储结构，但它们仍然归于线性表这一逻辑结构。

7. **在C语言中，数据对象仅涉及涉及数据的逻辑结构，而在C++等面向对象的编程语言中，数据对象不仅包括数据的存储结构和施加在该数据结构上的运算。**

### 算法和算法分析

#### 算法的概念

- 算法是指解决某类问的有限步骤或流程或一段指令序列。

- 算法的五个特征：

    1. **输入/输出**：这里输入/输出不是指存键盘，屏幕等设备输入或显示出具体的信息。而是指一组数据经过一个算法的处理得到处理后的数据，流向下一个算法或程序。 

    2. **确定性**：确定性是指算法的功能是确定的，经过该算法处理的数据必然会得到确定的预设的结果。

    3. **可行性**：算法的每一基本操作都是可以实施的，且能在有限的时间内完成。

    4. **有穷性**：有穷性是指算法的操作步骤是有限的，一组数据被输入，算法都能在有限的基本操作之后得到正确的结果。

    5. **正确性**：并不是所有算法都是正确的。在实际问题中，往往有些算法在问题规模足够大或足够小时，该算法也能正确得到结果。因此，可以称这些算法在特定的问题规模中是有效的或者正确的。所以，在衡量一个算法的好坏时，问题规模是一个不可被忽略的重要因素。   

#### 设计算法的三个阶段

- 从问题出发，找到可能的解决方案，制定合理的算法；

- 建立解决问题的数据模型和程序框架内，使用伪代码描述基本操作；

- 使用编程语言具体实现算法。

#### 算法的基本方法

- **穷举法**：穷举法主要依赖计算机的强大计算能力。

- **迭代法**：需要找出输入跟输出之间的迭代关系。

- **递推法**：递推法需要算法设计者有一定的数学递推分析能力。

- **递归法**：需要问题满足一个复杂对象包含一个或多个结构相同且相对简单的子对象。

#### 疑难解答

1. **算法的输入和输出**

        答：算法的输入跟输出并不是指实际生活中通过键盘或屏幕等设备输入和显示数据。实际上，算法不可能独立于程序单独存在，在实际编程中，某些程序模块（函数，方法）需要向该算法中传递数据，也有模块（函数，方法）从该算法中接收数据，这里的传送，接收等可以认为是算法的输入和输出。

2. **如果一个算法多层嵌套地调用了其他算法，该算法是否违背了算法可行性的要求？**

        答：算法的多层嵌套是非常常见的。算法的可行性要求算法的每一条语句都足够基本，并未强调每一条语句都必须跟机器指令有对应关系，而实指可以用基本操作或调用已经实现的基本算法来解决问题。


3. **如果一个算法内部有一个随系统状态会转移到不同指令地址的开关，它是否违背了算法的确定性要求？**

        答：算法的确定性是指算法的每一条路径执行得到结果都是确定的。因此该指令开关并不影响算法的确定性，但系统若存在不可知的状态，可能使得该算法得到不可预知的结果。

4. **递推法与递归法有何联系？**

        答：一个递推算法可转换为一个递归算法。但递归法不仅仅用于递推算法的实现。

5. **穷举法和递推法有何关系？**

        答：穷举法和递推法相同之处在于两者都包含穷举部分，不同在于，递推法当穷举一定次数后便可总结出递推关系，根据递推关系很容易知道下一步的递推结果，而穷举法则是一直穷举到被处理数据处理完为止。

#### 几种常见的算法

1. 试编写一个递推算法，计算下列级数的和：


$$S(x) = 1 + x + \frac{x^2}{2!} + \frac{x^3}{3!} + \frac{x^4}{4!} + \dots + \frac{x^n}{n!}$$

直到 $\frac{x^n}{n!} \lt 10^{-6}$ 。

- **C++编码实现**：

```C++
//递推计算阶乘
double RecursiveCalculateFactorial(double x)
{
    float s = 1.0;
    float t = 1.0;
    int n = 1;
    while (fabs(t) > 1e-6)
    {
        t = t * x / n;
        s = s + t;
        n++;
    }
    return s;
}
```
2. 编写一个穷举算法，求解“百钱买百鸡”问题。其中公鸡每只5钱，母鸡每只3钱，小鸡3只1钱。

- **C++编码实现**：

```C++
//“百钱买百鸡”问题
void HundredChickensWithHundredDollars(int cockPrice, int henPrice, int chickPrice, int &cockNum, int &henNum, int &chickNum)
{
    for (cockNum = 0; cockNum <= 100; cockNum++)
    {
        for (henNum = 0; henNum <= 100; henNum++)
        {
            for (chickNum = 0; chickNum <= 100; chickNum++)
            {
                if (cockNum + henNum + chickNum == 100 && cockPrice * cockNum + henPrice * henNum + chickPrice * chickNum == 100)
                    break;
            }
        }
    }
}
```

3. 使用递归算法正向打印数组元素和反向打印数组元素。

- **C++编码实现**：

```C++
//递归正向打印数组元素
void PrintArrayElementsForwardRecursively(int *arr, int length, int index)
{
    if (index >= length)
        return;
    cout << arr[index] << endl;
    PrintArrayElementsForwardRecursively(arr, length, index + 1);
}

//递归反向打印数组元素
void PrintArrayElementsBackwardRecursively(int *arr, int length, int index)
{
    if (index >= length)
        return;
    PrintArrayElementsBackwardRecursively(arr, length, index + 1);
    cout << arr[index] << endl;
}
```

### 算法分析

#### 算法评价的标准

算法评价的主要目的是通过科学合理的评价标准出一个算法的好坏，或者说明什么样的算法是一个好算法。

算法的评价标准有如下5个：

- **正确性**：正确性是一个算法的最主要特征。正确性要求算法必须能够正确执行预定的功能和性能的要求，通过有限次基本操作正确得到预定的结论。

- **健壮性**：健壮性是指算法能够自动来纠正其他程序或操作带来的错误，或将错误信息返回给编程人员。异常处理。

- **可读性**：一个优秀的算法需要有合理的，简单的，清晰的结构。变量名，函数名具有实际的含义，必要时还需要有注释。可读性主要为了他人能明白算法的设计思想或者功能。

- **高效性**：高效性是除了正确性之外算法应具备的最主要特性之一。人们往往希望在非常短的时间内解决问题。因此，一个算法的设计应当也应该在比较短的时间内得到答案。同时高效的算法也应当耗费最少的计算机资源。因此，衡量算法高效性的主要指标有时间复杂度和空间复杂度。其中时间复杂度关系到算法执行的快慢，而空间复杂度则衡量算法占用的内存空间的大小。时间复杂度，空间复杂度越小，算法越高效。

- 简单性：简单性是指一个算法的设计越简单越好，这样不仅实现起来容易，而且出错率也越低，可靠性越高，可读性越强。

#### 时间复杂度

时间复杂度主要衡量算法的快慢程度，但在实际问题中，一个算法在不同计算机中执行的速度往往是不同的，甚至在同一台计算机中的不同时刻，其执行速度也可能不同。算法的时间复杂度应该独立于这些因素的影响，因此，往往采用算法的执行频度来衡量算法的时间效率。所谓算法的执行频度 = 算法中每条指令执行次数之和。

算法的时间复杂度跟问题的规模有关，通常使用O来标记算法的时间复杂度。设问题规模为n，则算法的时间复杂度可表示为关于问题规模n的函数$y = f(n)$。在引入O标记法时，往往对 $f(n)$ 做一定处理：只取$f(n)$的最大项，并舍去最大项的常系数，从而表示为：$T(n)=O(f(n))$。
#### 空间复杂度

空间复杂度主要衡量算法（程序）占用内存的大小。一般来说，算法中与问题规模无关的内存分配（变量定义），其空间复杂度为常数，记为 $S(n) = O(1)$ 。而与问题规模有关的内存分配，需要具体分析。

#### 不同O标记的大小比较

若用 “<” 号来表示“优于”，则：

**$$O(c) \lt O(\log_2{n}) \lt O(n) \lt O(n \log_2{n}) \lt O(n^2) \lt O(n^3) \lt O(2^n) \lt O(3^n) \lt O(n!)$$**

在算法设计时，往往需要将时间复杂度控制在 **$\lt O(n \log_2{n})$** 时，算法的时间效率比较好。

当一个算法的时间复杂度达到 **$O(2^n)$** 或高于 **$O(2^n)$** 时，算法的运行时间将达到不可计算的程度。

#### 疑难解答

1. **为何for循环的执行次数为n+1?**

        答：设问题规模为n，则对于for循环，其判断部分 for(i = 1; i <=n ;i++)实际上是执行了n+1次，在n+1次判断i的值时，才出现不满足i<=n的情况，跳过循环体。因此，循环体是执行了n次，而循环判断部分执行了n+1次。

2. **已知程序有4个并列的程序段，它们的时间复杂度分别为 $T_1(n)=O(1);T_2(n)=O(n);T_3(n)=O(n^2);T_4(n)=O(2^n)$;整个程序的时间复杂度是多少？**

      答：以O为记号的时间复杂度，当多个时间复杂度并列时，采用“加法逻辑”，并保留最大项。因此该问题中整个程序的时间复杂度为 $T(n)=O(2^n)$。

3. **已知一个程序的时间复杂度为$T_1(n)=O(n)$，其中调用了两个子函数，一个子函数的时间复杂度为$T_2(n)=O(\log_2{n})$，另一个子函数的时间复杂度为$T_3(n)=O(n^2)$，整个程序的时间复杂度为多少？**

      答：有嵌套关系的函数，时间复杂度为各自时间复杂度的乘积，并列关系的函数时间复杂度取时间复杂都最高的。因此，该题中，整个程序的时间复杂度为：$T(n)=T_1(n) \times (T_2(n) + T_3(n) = O(n \times \max (\log_2{n},n^2))) = O(n \times n^2) = O(n^3)$ 。 