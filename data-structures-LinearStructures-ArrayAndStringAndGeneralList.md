## 数组，字符串，广义表

### 数组

#### 一维数组

##### 一维数组的概念与特点

1. **一维数组的概念**：一维数组也称为 **向量** 。是存储在一个连续存储空间中相同数据类型的有限序列。

2. **一维数组的特点**：一维数组既是逻辑结构，又是存储结构。
    
    - 作为逻辑结构，一维数组属于线性结构，但又区别于线性表，因为线性表只能看一定顺序存取，而一维数组可以直接存取。
    
    - 作为存储结构，一维数组可作为其他数据结构的顺序存储表示。

- **注**：这里介绍的一维数组有别于C/C++语言中一维数组的概念。C/C++编程语言中的一维数组仅仅作为一种存储结构，它不具备在一维数组存储结构上相关操作的实现。

##### 一维数组的实现

一维数组的实现非常简单，可以借助数组存储结构来定义一维数组的相关的结构，实现必要的操作即可。

**C++语言编程实现**：

```

```

---

#### 二维数组

##### 二维数组的概念与特点

二维数组可以看成是一维数组的扩展形式。在一维数组中，每个元素都是一个相同数据类型的数据元素，而二维数组，可以看成是一维数组中每个元素又是一个长度相等，数据元素类型相同的数组元素。二维数组常用A\[m]\[n]来表示。其中m表示行数，n表示列数。也可以认为，二维数组A\[m]\[n]是由一个长度为m的一维数组构成的，而这个一维数组的每个元素又是一个长度为n的一维数组。

从数据结构的逻辑关系来看，二维数组的每个数组元素被两个关系约束：在行的方向上元素处于一个线性关系，在列的方向上，元素同样也处于一个线性关系，它有两个直接前驱和两个直接后继。

##### 二维数组的实现

二维数组的实现，可参照一维数组。由于二维数组分行跟列，因此，将一个二维数组的元素存入连续的存储空间，分两种情况：

- **行优先**：行优先即固定列方向的地址，当行方向元素全部存入存储空间后，再进行下一行的存储。即按行存储。

- **列优先**：列优先则先固定行方向地址不动，将每列元素全部存入存储空间后，再进行下一列的存储。即按列存储。

在二维数组中。存取任意元素的时间相同，且均为O(1)。

根据二维数组，一维数组可继续推广至三维甚至多维(n维，n大于等于3)。

**C++语言编程实现**：

```C++

```

##### 疑难解答

1. **一维数组是线性结构？它是逻辑结构还是存储结构？**

>答：一维数组是线性结构。它既是逻辑结构也是存储结构。

2. **一维数组一旦被放满可以扩充？**

>答：静态定义的一维数组不能扩充，动态定义的一维数组，放满后可重新分配存储空间进行扩充。

3. **对于一维数组只能直接存取吗？**

>答：一维数组可以按照元素下标直接存取，当把数组看作数据对象时，也可实现随机存取。

4. **如何存取使用指针动态定义一维数组？**

>答：可以定义一个指针ptr指向一维数组的首地址（也是数组中第一个元素的地址）。由于一维数组的元素是相继顺序存储的，因此可以使用ptr++或ptr--分别或取前一个或后一个元素的位置。使用时要注意越界（即指针ptr超出了一维数组的边界）。

5. **二维数组是线性结构？**

>答：从二维数组的构成上看，可以认为二维数组是由每个元素都是一个长度相等，元素类型相同的一维数组而构成的一维数组，因此，它是线性结构。但从二维数组的特点来看，它实际上与行列式（矩阵）对应，是二维平面的，自然是非线性结构。一般将二维数组认为是最简单的非线性结构。

6. **二维数组是按一维数组存储的吗？如何计算二维数组中元素的存储地址？**

>答：二维数组是按一维数组存储的。在存储过程中，将二维数组中每个元素的相对逻辑地址（索引，下标）转化为一维的关系，再进行存储。实际操作中需要分按行存取（行优先）还是按列存取（列优先）。

7. **通过矩阵元素的行，列下标如何计算通过它的正对角线（从左上到右下）和反对角线（从左下到右上）的编号？**

>答：根据矩阵行，列下标的编号，有两种编号：
>
>(1). 设矩阵行，列下标i到j都是从1到n，正对角线和反对角线的编号k和k'都从1到2n-1，则：k = i + j - 1 ，k' = n - i + j 。 
>
>(2). 设矩阵行，列下标i到j都是从0到n-1，正对角线和反对角线的编号k和k'都从0到2n-2，则：k = i + j ，k' = n - i + j - 1 。 

##### 数组相关算法

1. 设有一个整数序列 $（e_1,e_2,\cdots,e_n）$ 存放在一维数A\[size]中的前n个数组元素的位置。设计一个算法，将这个序列原地逆置，即将数组的前n个原址内容置换为 $（e_n,e_{n-1},\cdots,e_1）$ 。

**C++语言编程实现**：

```C++

```

2. 假设数组A\[n]中有多个0元素，编写一个算法，将A中所有非0元素依次移到数组A的前端A\[i] $（0 \leq i \leq n-1）$ 。

**C++语言编程实现**：

```C++

```

3. 在数组A\[n]中有n个不同的元素，编写一个算法，将A中所有数值在1到n之间的整数从小到大排序后从0号位置起连续存入数组B\[n]中，函数返回这些整数的个数。要求算法的时间复杂度为O(n)。

**C++语言编程实现**：

```C++

```

4. 编写一个算法，将 一个有n个非0元素的整数一维数组A\[n]拆分为两个一维数组，使得A中大于0的元素存放在数组B中，小于0的元素存放在数组C中。

**C++语言编程实现**：

```C++

```

5. 给定一个一维数组A\[n]，称A中连续相等的整数构成的子序列为平台。编写一个算法，求出并返回A中最长平台的长度和起始地址（下标，索引，从0开始）。

**C++语言编程实现**：

```C++

```

6. 已知一维数组A\[m+n]中依次存放着两个表 $（a_1,a_2,\cdots,a_n）$ 和 $（b_1,b_2,\cdots,b_n）$ 。编写一个算法，将数组中两个表的位置互换，即将$（b_1,b_2,\cdots,b_n）$ 放在 $（a_1,a_2,\cdots,a_n）$ 前面。

**C++语言编程实现**：

```C++

```

7. 假设数组A\[n]中有多个0元素，编写一个算法，将A中所有非0元素依次移到数组A的前端A\[i] $（0 \leq i \leq n-1）$ 。

**C++语言编程实现**：

```C++

```

8. 若矩阵 $A_{m \times n}$ 中的某一组元素A\[i]\[j]是第i行中的最小值，同时又是第j列的最小值，则称此元素为该矩阵的一个鞍点。假设以二维数组存放矩阵，试设计一个算法，找出该矩阵中鞍点在二维数组中的位置（若鞍点存在时），并给出该算法的时间复杂度。

**C++语言编程实现**：

```C++

```

9. 设整数数组B\[m+1]\[n+1]的数据在行，列方向上都是按从小到大的顺序排列，且整型变量x中的数据在B中存在。试设计一个算法，找出一对满足B\[i]\[j]==x的i,j的值，同时要求比较次数不超过m + n。

**C++语言编程实现**：

```C++

```

10. 对于一个n阶方阵，试编写一个算法，通过行变换使其按每行元素的平均值递增的顺序排列。

**C++语言编程实现**：

```C++

```

11. 拉丁方阵是轮回方阵的一种。试编写一个算法，构造n阶拉丁方阵。

**C++语言编程实现**：

```C++

```

12. 试编写一个算法，将自然数 $1 ~ n^2 $ 按“蛇形”填入 $n \times n$ 的矩阵中（蛇形矩阵）。

**C++语言编程实现**：

```C++

```

12. 试编写一个算法，将自然数 $1 ~ n^2 $ 按“螺旋形”填入 $n \times n$ 的矩阵中（螺旋矩阵）。

**C++语言编程实现**：

```C++

```

---

#### 矩阵

##### 特殊矩阵的压缩存储

###### 对称矩阵的压缩存储

1. **对称矩阵的概念**：对一个 $n \times n$ 的矩阵A中的任一元素 $a_{ij}$ ，当且仅当 $a_{ij} = a_{ji}(0 \leq i \leq n-1, 0 \leq j \leq n-1)$ ，矩阵A称为对称矩阵。

2. **对称矩阵的特性**：对一个 $n \times n$ 的对称矩阵A：矩阵元素总数有 &n^2& 个，而上三角阵或下三角阵的元素共有 $n + (n - 1) + (n - 2) + \cdots + 2 + 1 = \frac{n(n + 1)}{2}$ 个元素。因此，对称矩阵的压缩存储最多只需存储 $\frac{n(n + 1)}{2}$ 个元素。

3. **对称矩阵的压缩存储**：可以用一维数组B存储对称矩阵A的上三角阵或下三角阵。为了找到元素在上三角阵或下三角阵中的位置，还需区分行优先跟列优先方式。

4. **存储方式及元素位置**：假设在一维数组B的0号位置开始存放，A\[0]\[0]存放在B\[0]。则：

    - 若只存储下三角阵，并按行优先存储。对于A中的任一数组元素 $a_{ij}$ ，在按行优先存放的情形下，当 $i \geq j$ 时，矩阵元素 $a_{ij}$ 在数组B中对应存放位置为：

    $$LOC(i,j) = 1 + 2 + \cdots + i + j = \frac{i(i + j)}{2} + j$$

    - 若只存储上三角阵，并按行优先存储。对于A中的任一数组元素 $a_{ij}$ ，在按行优先存放的情形下，当 $i \leq j$ 时，矩阵元素 $a_{ij}$ 在数组B中对应存放位置为：

    $$LOC(i,j) = n + (n - 1) + \cdots + (n - i + 1) + (j - i)$$
    $$ = \frac{i(2n - i + 1)}{2} + j - i = \frac{2n - i - 1}{2} + j$$

###### 三对角线矩阵

1. **三角线矩阵的概念**：设有一个 $n \times n$ 的矩阵A，对于矩阵A中的任一元素 $a_{ij}$ ，当 $|i - j| \gt 1$ 时，有 $a_{ij} = 0 (1 \leq i \leq n, 1 \leq j \leq n)$ ，则称这样额矩阵为三角线矩阵。

2. **三角线矩阵的压缩存储**：对于三角线矩阵，除对角线及在主对角线上下相邻的两条对角线上的元素外，所有其他元素均为0。为了节省存储空间，只存储对角线及其上下两侧次对角线上的元素，主次对角线以外的0元素一律不存储。存储时同样要分按行优先还是按列优先方式存储。

3 **存储方式及元素位置**：若将三对角线矩阵A中三条对角线上的元素按行优先存储方式存储在一维数组B中，且 $a_{11}$ 存放在B\[0] 中，则矩阵A在三条对角线上的元素 $a_{ij}(1 \leq i \leq n, i-1 \leq j \leq i+1)$ 在一维数组B中的存放位置为:

$$2i + j - 3$$

若三对角线矩阵中某元素 $a_{ij}$ 在一维数组B中的存放位置为k，则可根据下列公式分别求得该元素在三对角线矩阵中的位置（下标i,j的值）：

$$i = \frac{k+1}{3} + 1 ， j = k - 2i + 3$$

###### 疑难解答

1. **对称矩阵是否是稀疏矩阵？**

>答：当n行n列的对称矩阵中非0元素的个数t远远小于 $n^2$ 时，对称矩阵也是稀疏矩阵。三对角矩阵是稀疏矩阵。

2. **计算对称矩阵在压缩数组中的存放位置时要注意什么问题？**

>答：要注意：矩阵是按上三角还是下三角存放；是按照行优先还是列优先存储；数组元素的下标从0开始还是从1开始；按下三角存放时是否 $i \geq j$ ，按上三角存放时是否 $i \leq j$ 。

3. **两个对称矩阵相加，结果是对称矩阵；两个对称矩阵相乘，结果还是对称矩阵吗？**

>答：两个对称矩阵相乘，结果可能不对称，除非这两个矩阵相同。

4. **两个三角矩阵相加，结果还是三角矩阵；两个三角矩阵相乘，结果还是三角矩阵吗？**

>答：两个三角矩阵相乘，结果不再是三角矩阵。

5. **为什么特殊矩阵极少使用链式存储？**

>答：因为要占据额外的存储空间且操作复杂。

6. **特殊矩阵在压缩存储后是否失去了随机存取的功能？**

>答：特殊矩阵在压缩存储后，并不影响随机存取的功能。特殊矩阵压缩存储时，相对位置是按照其特点计算出来的。同样在还原是也可根据其在存储数组中的位置算出在原有特殊矩阵中对应的位置，它仍然满足随机存取的特点。

##### 稀疏矩阵

###### 稀疏矩阵的相关概念与运算

1. **稀疏矩阵的定义**：一个矩阵中非0元素的个数远远小于矩阵元素的总个数，则称该矩阵为稀疏矩阵。在实际应用中，稀疏矩阵一般比较大，而非0元素一般比较少。

2. **稀疏矩阵的存储**：

    - **二维数组存储**：跟一般矩阵一样，采用二维数组来存储稀疏矩阵。优点是可以随机访问每一个元素，容易实现诸如加减法，乘除法，转置等运算。缺点是浪费大量空间来存放0元素，计算时花费大量时间来处理0元素的无效计算。

    - **三元组表存储**：矩阵中的每个非0元素可用该元素的行号i，列号j及元素值 $a_{ij}$ 来组成三元组 $(i , i , a_{ij})$ 来表示。若将所有的三元组按行号为主序，列号为辅序（行号相同时再考虑列号）进行排序，则构成一个表示稀疏矩阵的三元组表。

3. **稀疏矩阵的顺存储**：

    - 稀疏矩阵的三元组结构定义如下：

```C++
typedef int ElementType;

struct Triple{
    int row;
    int col;
    ElementType value;
};
```
    - 稀疏矩阵的顺序存储类型定义如下：

```C++
const int MAX_SIZE = 100;

struct SparseMatrix{
    int rows;
    int cols;
    int terms;
    Triple elem[MAX_SIZE];
};

```

4. **稀疏矩阵的链式存储**：

稀疏矩阵的链式存储采用十字链表表示，它为每个非0元素结点附带了两个指针：一个表示同一行下一非0元素结点（行指针），另一个指示同一行下一非0元素结点（列指针）。在十字链表中，每一个三元结点按矩阵元素所在行号i和列号j,链接在第i个行链表和第j个列来链表中，即处于所在的行链表和列链表的交汇处。

5. **稀疏矩阵的运算**：

- 稀疏矩阵的三元组表表示的缺点是失去了矩阵随机存取的特性；

- 稀疏矩阵的转置运算可以设计两个辅助表格，通过一遍扫描三元组表，预先统计原矩阵中各列非0元素的个数，预置转置后矩阵各行非0元素在三元组表中的位置。

- 稀疏矩阵的加法可以设计一个辅助向量，在逐行做加法时存放一行相加的结果，再压缩存放到结果三元组表中。结果保存仍继续保存回三元组表是因为可能出现新的非0元素。

- 稀疏矩阵相乘同样可以设计一个辅助向量，在逐行做乘法时，用于累加相乘结果，最后再压缩存入结果三元组表。

###### 疑难解答

1. **为什么稀疏矩阵的三元组表结构失去了直接存取特性，只能顺序存放？**

>答：对于稀疏矩阵的三元组表，只能按“行号”和“列号”顺序查找，以存取需要的数据元素的值，不能直接存取。

2. **两个稀疏矩阵相加，结果是稀疏矩阵（0元素的个数可能会有变化）；两个稀疏矩阵相乘，结果还是稀疏矩阵吗？**

>答：两个稀疏矩阵相乘，结果不一定是稀疏矩阵。

3. **采用带行指针的二元组表，相对于三元组表，有什么优点？**

>答：采用带行指针的二元组表，可以直接找到某行，且消除了三元组表中冗余的行号。在二元组表内搜索某列元素还需顺序擦查找，但个数少得多。

4. **为加快稀疏矩阵转置，相加和相乘的速度，一般设置哪两个数组？**

>答：一个存储目标矩阵的每行（或列）的非零元素个数，一个设定目标矩阵各行（或列）的开始存放地址。

---

### 字符串

#### 字符串相关概念

1. **字符串的定义**：字符串是由0各或多个字符的顺序排列所组成的线性序列，其基本组成元素是单个的字符（char），字符串的长度可变。

2. **串值和串名**：串值是可以直接引用的串，一般用一对''号或""作为分界符括起来。串名包括串变量名或串常量名，可以将字符串赋值给它，此后可以使用串名来使用串。

3. **串长度**：串长度是指串中字符的个数。长度等于0为空串。C/C++语言中字符串末尾的'\0'表示字符串结束符，不计入串长度。

4. **子串**：若一个字符串不为空，从该字符串中任意取出一段字符串称为该字符串的子串。

5. **前缀子串**：从字符串的开始第一个字符开始，连续取出若干个字符组成的字符串称为该字符串的前缀子串。

6. **后缀字串**：从字符串的某一位置开始到该字符串结束位置的连续字符构成的字符串称为该字符串的后缀字串。

7。 **串的模式匹配**：求子串在串中的位置的运算叫做串的连续模式匹配。

---

#### 字符串的初始化和赋值

---

#### 自定义字符串

---

#### 字符串的模式匹配

---

#### 疑难解答

#### 字符串相关算法

### 广义表