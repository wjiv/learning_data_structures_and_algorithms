## 数组，字符串，广义表

### 数组

#### 一维数组

##### 一维数组的概念与特点

1. **一维数组的概念**：一维数组也称为 **向量** 。是存储在一个连续存储空间中相同数据类型的有限序列。

2. **一维数组的特点**：一维数组既是逻辑结构，又是存储结构。
    
    - 作为逻辑结构，一维数组属于线性结构，但又区别于线性表，因为线性表只能看一定顺序存取，而一维数组可以直接存取。
    
    - 作为存储结构，一维数组可作为其他数据结构的顺序存储表示。

- **注**：这里介绍的一维数组有别于C/C++语言中一维数组的概念。C/C++编程语言中的一维数组仅仅作为一种存储结构，它不具备在一维数组存储结构上相关操作的实现。

##### 静态和动态一维数组

1. **静态一维数组**：一维数组的声明可以是静态的，也就是使用语句：**ElementType array\[size]** 来声明数组变量。这种方式比较简单，但是当数组中元素的个数为等于数组长度size时，数组满，此后再不能向数组中添加元素。即静态数组中只能存放不多于数组长度的元素。使用静态数组解决问题时，需要提前估计所用数组的大小，声明的数组太小，不能满足问题的需要，太大又造成空间浪费。静态内存的分配过程也称决策前分配方式。静态数组的结构，类型不能改变，程序结束后自动撤销。

2. **动态一维数组**：所谓动态数组，是指在程序执行过程中分配内存的方式。C语言中借助malloc函数动态分配存储空间，C++语言中使用new关键字分配存储空间。动态分配的好处是可以按需分配存储空间。缺点是动态分配的内存空间在程序执行结束时不能自动释放分配空间，必须显式地用命令释放，C语言中使用free函数，C++语言中使用delete关键字。

---

#### 二维数组

##### 二维数组的概念与特点

二维数组可以看成是一维数组的扩展形式。在一维数组中，每个元素都是一个相同数据类型的数据元素，而二维数组，可以看成是一维数组中每个元素又是一个长度相等，数据元素类型相同的数组元素。二维数组常用A\[m]\[n]来表示。其中m表示行数，n表示列数。也可以认为，二维数组A\[m]\[n]是由一个长度为m的一维数组构成的，而这个一维数组的每个元素又是一个长度为n的一维数组。

从数据结构的逻辑关系来看，二维数组的每个数组元素被两个关系约束：在行的方向上元素处于一个线性关系，在列的方向上，元素同样也处于一个线性关系，它有两个直接前驱和两个直接后继。

##### 二维数组的存储

二维数组的实现，可参照一维数组。由于二维数组分行跟列，因此，将一个二维数组的元素存入连续的存储空间，分两种情况：

- **行优先**：行优先即固定列方向的地址，当行方向元素全部存入存储空间后，再进行下一行的存储。即按行存储。

- **列优先**：列优先则先固定行方向地址不动，将每列元素全部存入存储空间后，再进行下一列的存储。即按列存储。

在二维数组中。存取任意元素的时间相同，且均为O(1)。

根据二维数组，一维数组可继续推广至三维甚至多维(n维，n大于等于3)。

##### 疑难解答

1. **一维数组是线性结构？它是逻辑结构还是存储结构？**

>答：一维数组是线性结构。它既是逻辑结构也是存储结构。

2. **一维数组一旦被放满可以扩充？**

>答：静态定义的一维数组不能扩充，动态定义的一维数组，放满后可重新分配存储空间进行扩充。

3. **对于一维数组只能直接存取吗？**

>答：一维数组可以按照元素下标直接存取，当把数组看作数据对象时，也可实现随机存取。

4. **如何存取使用指针动态定义一维数组？**

>答：可以定义一个指针ptr指向一维数组的首地址（也是数组中第一个元素的地址）。由于一维数组的元素是相继顺序存储的，因此可以使用ptr++或ptr--分别或取前一个或后一个元素的位置。使用时要注意越界（即指针ptr超出了一维数组的边界）。

5. **二维数组是线性结构？**

>答：从二维数组的构成上看，可以认为二维数组是由每个元素都是一个长度相等，元素类型相同的一维数组而构成的一维数组，因此，它是线性结构。但从二维数组的特点来看，它实际上与行列式（矩阵）对应，是二维平面的，自然是非线性结构。一般将二维数组认为是最简单的非线性结构。

6. **二维数组是按一维数组存储的吗？如何计算二维数组中元素的存储地址？**

>答：二维数组是按一维数组存储的。在存储过程中，将二维数组中每个元素的相对逻辑地址（索引，下标）转化为一维的关系，再进行存储。实际操作中需要分按行存取（行优先）还是按列存取（列优先）。

7. **通过矩阵元素的行，列下标如何计算通过它的正对角线（从左上到右下）和反对角线（从左下到右上）的编号？**

>答：根据矩阵行，列下标的编号，有两种编号：
>
>(1). 设矩阵行，列下标i到j都是从1到n，正对角线和反对角线的编号k和k'都从1到2n-1，则：k = i + j - 1 ，k' = n - i + j 。 
>
>(2). 设矩阵行，列下标i到j都是从0到n-1，正对角线和反对角线的编号k和k'都从0到2n-2，则：k = i + j ，k' = n - i + j - 1 。 

##### 数组相关算法

1. 设有一个整数序列 $（e_1,e_2,\cdots,e_n）$ 存放在一维数A\[size]中的前n个数组元素的位置。设计一个算法，将这个序列原地逆置，即将数组的前n个原址内容置换为 $（e_n,e_{n-1},\cdots,e_1）$ 。

**C++语言编程实现**：

```C++
/*设有一个整数序列 $（e_1,e_2,\cdots,e_n）$ 存放在一维数A\[size]中的前n个数组
    元素的位置。设计一个算法，将这个序列原地逆置，即将数组的前n个原址内容置换为 
    $（e_n,e_{n-1},\cdots,e_1）$ 。*/
void ReverseArray(int *arr, int length)
{
    if (length == 0)
        return;
    int tmp = 0;
    for (int i = 1; i <= length / 2; i++)
    {
        tmp = arr[i - 1];
        arr[i - 1] = arr[length - i];
        arr[length - i] = tmp;
    }
}
```

2. 假设数组A\[n]中有多个0元素，编写一个算法，将A中所有非0元素依次移到数组A的前端A\[i] $（0 \leq i \leq n-1）$ 。

**C++语言编程实现**：

```C++
/*假设数组A\[n]中有多个0元素，编写一个算法，将A中所有非0元素依次移到数组A的前端
    A\[i] $（0 \leq i \leq n-1）$ 。*/
void MoveToNonzeroElementToFront(int *arr, int length)
{
    int index = 0;
    for (int i = 0; i < length; i++)
    {
        if (arr[i] != 0)
        {
            if (i != index)
            {
                arr[index] = arr[i];
                arr[i] = 0;
            }
            index++;
        }
    }
}
```

3. 在数组A\[n]中有n个不同的元素，编写一个算法，将A中所有数值在1到n之间的整数从小到大排序后从0号位置起连续存入数组B\[n]中，函数返回这些整数的个数。要求算法的时间复杂度为O(n)。

**C++语言编程实现**：

```C++
/*在数组A\[n]中有n个不同的元素，编写一个算法，将A中所有数值在1到n之间的整数从小
    到大排序后从0号位置起连续存入数组B\[n]中，函数返回这些整数的个数。要求算法的时间
    复杂度为O(n)。*/
void Rearrange(int *arrA, int *arrB, int length, int &count)
{
    count = 0;
    int index = 0;
    for (int i = 0; i < length; i++)
    {
        arrB[i] = 0;
    }
    for (int i = 0; i < length; i++)
    {
        if (arrA[i] >= 1 && arrA[i] <= length)
        {
            arrB[arrA[i] - 1] = arrA[i];
            count++;
        }
    }
    for (int i = 0; i < length; i++)
    {
        if (arrB[i])
        {
            if (i != index)
            {
                arrB[index] = arrB[i];
            }
            index++;
        }
    }
}
```

4. 编写一个算法，将 一个有n个非0元素的整数一维数组A\[n]拆分为两个一维数组，使得A中大于0的元素存放在数组B中，小于0的元素存放在数组C中。

**C++语言编程实现**：

```C++
/*编写一个算法，将 一个有n个非0元素的整数一维数组A\[n]拆分为两个一维数组，使得A
    中大于0的元素存放在数组B中，小于0的元素存放在数组C中。*/
void SplitArray(int *arrA, int *arrB, int *arrC, int lengthA, int &countB, int &countC)
{
    countB = 0;
    countC = 0;
    for (int i = 0; i < lengthA; i++)
    {
        if (arrA[i] > 0)
        {
            arrB[countB] = arrA[i];
            countB++;
        }
        else
        {
            arrB[countC] = arrA[i];
            countC++;
        }
    }
}
```

5. 给定一个一维数组A\[n]，称A中连续相等的整数构成的子序列为平台。编写一个算法，求出并返回A中最长平台的长度和起始地址（下标，索引，从0开始）。

**C++语言编程实现**：

```C++
/*给定一个一维数组A\[n]，称A中连续相等的整数构成的子序列为平台。编写一个算法，求
    出并返回A中最长平台的长度和起始地址（下标，索引，从0开始）。*/
void GetMaxLongSubSequence(int *arr, int length, int &startIndex, int &subSequenceLength)
{
    startIndex = 0;
    subSequenceLength = 0;
    int i = 0;
    int k = 0;
    int t = 0;
    while (i < length)
    {
        k = 1;
        i++;
        while (i < length && arr[i - 1] == arr[i])
        {
            k++;
            i++;
        }
        if (k > subSequenceLength)
        {
            subSequenceLength = k;
            startIndex = t;
        }
        t = i;
    }
}
```

6. 已知一维数组A\[m+n]中依次存放着两个表 $（a_1,a_2,\cdots,a_n）$ 和 $（b_1,b_2,\cdots,b_n）$ 。编写一个算法，将数组中两个表的位置互换，即将$（b_1,b_2,\cdots,b_n）$ 放在 $（a_1,a_2,\cdots,a_n）$ 前面。

**C++语言编程实现**：

```C++
/*已知一维数组A\[m+n]中依次存放着两个表 $（a_1,a_2,\cdots,a_n）$ 和 
    $（b_1,b_2,\cdots,b_n）$ 。编写一个算法，将数组中两个表的位置互换，即将
    $（b_1,b_2,\cdots,b_n）$ 放在 $（a_1,a_2,\cdots,a_n）$ 前面。*/
void ExchangeArraySequence(int *arr, int m, int n)
{
    int tmp = m + n;
    int p = m;
    int k = tmp % p;
    int i = 0;
    int j = 0;
    while (k != 0)
    {
        tmp = p;
        p = k;
        k = tmp % p;
    }
    for (k = 0; k < p; k++)
    {
        tmp = arr[k];
        i = k;
        j = (i + m) % (m + n);
        while (j != k)
        {
            arr[i] = arr[j];
            i = j;
            i = (j + m) % (m + n);
        }
        arr[i] = tmp;
    }
}
```

7. 若矩阵 $A_{m \times n}$ 中的某一组元素A\[i]\[j]是第i行中的最小值，同时又是第j列的最小值，则称此元素为该矩阵的一个鞍点。假设以二维数组存放矩阵，试设计一个算法，找出该矩阵中鞍点在二维数组中的位置（若鞍点存在时），并给出该算法的时间复杂度。

**C++语言编程实现**：

```C++
/*若矩阵 $A_{m \times n}$ 中的某一组元素A\[i]\[j]是第i行中的最小值，同时又是
    第j列的最小值，则称此元素为该矩阵的一个鞍点。假设以二维数组存放矩阵，试设计
    一个算法，找出该矩阵中鞍点在二维数组中的位置（若鞍点存在时），并给出该算法的
    时间复杂度。*/
void LocateSaddlePoint(int **arr, int m, int n)
{
    int min;
    int i;
    int j;
    int k;
    int flag;
    for (i = 0; i < m; i++)
    {
        min = 0;
        for (j = 0; j < n; j++)
        {
            if (arr[i][j] < arr[i][min])
                min = j;
        }
        flag = 1;
        for (k = 0; k < m; k++)
        {
            if (arr[i][min] < arr[k][min])
                flag = 0;
        }
        if (flag == 1)
        {
            cout << "Saddle Point Is :(" << i << "," << min << "),Value=" << arr[i][min] << endl;
        }
    }
}
```

8. 设整数数组B\[m+1]\[n+1]的数据在行，列方向上都是按从小到大的顺序排列，且整型变量x中的数据在B中存在。试设计一个算法，找出一对满足B\[i]\[j]==x的i,j的值，同时要求比较次数不超过m + n。

**C++语言编程实现**：

```C++
/*设整数数组B\[m+1]\[n+1]的数据在行，列方向上都是按从小到大的顺序排列，且整型变
    量x中的数据在B中存在。试设计一个算法，找出一对满足B\[i]\[j]==x的i,j的值，同
    时要求比较次数不超过m + n。*/
void FindValueEqualGiveValue(int **arr, int m, int n, int value, int &i, int &j)
{
    i = 0;
    i = n;
    while (arr[i][j] != value)
    {
        if (arr[i][j] < value)
            i++;
        else
            j--;
    }
}
```

9. 对于一个n阶方阵，试编写一个算法，通过行变换使其按每行元素的平均值递增的顺序排列。

**C++语言编程实现**：

```C++
/*对于一个n阶方阵，试编写一个算法，通过行变换使其按每行元素的平均值递增的顺序排列。*/
void Arrange(int **arr, int n)
{
    int sum[n];
    int add[n];
    int i, j, k, p, tmp;
    for (i = 0; i < n; i++)
    {
        sum[i] = 0;
        add[i] = i;
        for (j = 0; j < n; j++)
        {
            sum[i] = sum[i] + arr[i][j];
        }
    }
    for (i = 0; i < n - 1; i++)
    {
        k = i;
        for (j = i + 1; j < n; j++)
        {
            if (sum[j] < sum[k])
                k = j;
        }
        if (i != k)
        {
            tmp = sum[i];
            sum[i] = sum[k];
            sum[k] = tmp;
            tmp = add[i];
            add[i] = add[k];
            add[k] = tmp;
        }
    }
    for (i = 0; i == add[i]; i++)
        k = add[i];
    p = i;
    for (j = 0; i < n; j++)
    {
        sum[j] = arr[i][j];
    }
    while (k != p)
    {
        for (j = 0; j < n; j++)
        {
            arr[i][j] = arr[k][j];
        }
        i = k;
        k = add[k];
    }
    for (j = 0; j < n; j++)
    {
        arr[i][j] = sum[j];
    }
}
```

10. 拉丁方阵是轮回方阵的一种。试编写一个算法，构造n阶拉丁方阵。

**C++语言编程实现**：

```C++
//拉丁方阵是轮回方阵的一种。试编写一个算法，构造n阶拉丁方阵。
void LatinMatrix(int **arr, int n)
{
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (i + j + 1 < n)
                arr[i][j] = i + j + 1;
            else
                arr[i][j] = i + j + 1 - n;
        }
    }
}
```

11. 试编写一个算法，将自然数 $1 ~ n^2 $ 按“蛇形”填入 $n \times n$ 的矩阵中（蛇形矩阵）。

**C++语言编程实现**：

```C++
/*试编写一个算法，将自然数 $1 ~ n^2 $ 按“蛇形”填入 $n \times n$ 的矩阵中
    （蛇形矩阵）。*/
void FillNaturalNumberInSnakeMatrix(int **arr, int n)
{
    int m = 1;
    int row = 0;
    int col = 0;
    int j = 0;
    int i = 0;
    for (int k = 0; k < 2 * n - 1; k++)
    {
        if (k <= n)
            j = k;
        else
            j = 2 * n - k;
        for (i = 0; i < j; i++)
        {
            if (k <= n)
            {
                if (k % 2)
                {
                    row = k + i - 1;
                    col = i;
                }
                else
                {
                    row = i;
                    col = k - i - 1;
                }
            }
            else
            {
                row = k + i - n;
                col = k - row - 1;
            }
            arr[row][col] = m;
            m++;
        }
    }
}
```

12. 试编写一个算法，将自然数 $1 ~ n^2 $ 按“螺旋形”填入 $n \times n$ 的矩阵中（螺旋矩阵）。

**C++语言编程实现**：

```C++
/*试编写一个算法，将自然数 $1 ~ n^2 $ 按“螺旋形”填入 $n \times n$ 的矩阵中
    （螺旋矩阵）。*/
void FillNaturalNumberInSpiralMatrix(int **arr, int n)
{
    int i = 0;
    int j = 0;
    int flag = 0;
    for (i = 0; i < n; i++)
    {
        for (j = 0; j < n; j++)
        {
            arr[i][j] = 0;
        }
    }
    i = 0;
    j = 0;
    for (int m = 1; m < n * n; m++)
    {
        arr[i][j] = m;
        if (flag = 0)
        {
            if (i + 1 < n && arr[i + 1][j] == 0)
                i++;
            else
            {
                j++;
                flag = 1;
            }
        }
        if (flag = 1)
        {
            if (j + 1 < n && arr[i][j + 1] == 0)
                j++;
            else
            {
                i--;
                flag = 2;
            }
        }
        if (flag == 2)
        {
            if (i - 1 > 0 && arr[i - 1][j] == 0)
                i--;
            else
            {
                j--;
                flag = 3;
            }
        }
        if (flag == 3)
        {
            if (j - 1 > 0 && arr[i][j - 1] == 0)
                j--;
            else
            {
                i++;
                flag = 0;
            }
        }
    }
}
```

---

#### 矩阵

##### 特殊矩阵的压缩存储

###### 对称矩阵的压缩存储

1. **对称矩阵的概念**：对一个 $n \times n$ 的矩阵A中的任一元素 $a_{ij}$ ，当且仅当 $a_{ij} = a_{ji}(0 \leq i \leq n-1, 0 \leq j \leq n-1)$ ，矩阵A称为对称矩阵。

2. **对称矩阵的特性**：对一个 $n \times n$ 的对称矩阵A：矩阵元素总数有 &n^2& 个，而上三角阵或下三角阵的元素共有 $n + (n - 1) + (n - 2) + \cdots + 2 + 1 = \frac{n(n + 1)}{2}$ 个元素。因此，对称矩阵的压缩存储最多只需存储 $\frac{n(n + 1)}{2}$ 个元素。

3. **对称矩阵的压缩存储**：可以用一维数组B存储对称矩阵A的上三角阵或下三角阵。为了找到元素在上三角阵或下三角阵中的位置，还需区分行优先跟列优先方式。

4. **存储方式及元素位置**：假设在一维数组B的0号位置开始存放，A\[0]\[0]存放在B\[0]。则：

    - 若只存储下三角阵，并按行优先存储。对于A中的任一数组元素 $a_{ij}$ ，在按行优先存放的情形下，当 $i \geq j$ 时，矩阵元素 $a_{ij}$ 在数组B中对应存放位置为：

    $$LOC(i,j) = 1 + 2 + \cdots + i + j = \frac{i(i + j)}{2} + j$$

    - 若只存储上三角阵，并按行优先存储。对于A中的任一数组元素 $a_{ij}$ ，在按行优先存放的情形下，当 $i \leq j$ 时，矩阵元素 $a_{ij}$ 在数组B中对应存放位置为：

    $$LOC(i,j) = n + (n - 1) + \cdots + (n - i + 1) + (j - i)$$
    $$ = \frac{i(2n - i + 1)}{2} + j - i = \frac{2n - i - 1}{2} + j$$

###### 三对角线矩阵

1. **三角线矩阵的概念**：设有一个 $n \times n$ 的矩阵A，对于矩阵A中的任一元素 $a_{ij}$ ，当 $|i - j| \gt 1$ 时，有 $a_{ij} = 0 (1 \leq i \leq n, 1 \leq j \leq n)$ ，则称这样额矩阵为三角线矩阵。

2. **三角线矩阵的压缩存储**：对于三角线矩阵，除对角线及在主对角线上下相邻的两条对角线上的元素外，所有其他元素均为0。为了节省存储空间，只存储对角线及其上下两侧次对角线上的元素，主次对角线以外的0元素一律不存储。存储时同样要分按行优先还是按列优先方式存储。

3 **存储方式及元素位置**：若将三对角线矩阵A中三条对角线上的元素按行优先存储方式存储在一维数组B中，且 $a_{11}$ 存放在B\[0] 中，则矩阵A在三条对角线上的元素 $a_{ij}(1 \leq i \leq n, i-1 \leq j \leq i+1)$ 在一维数组B中的存放位置为:

$$2i + j - 3$$

若三对角线矩阵中某元素 $a_{ij}$ 在一维数组B中的存放位置为k，则可根据下列公式分别求得该元素在三对角线矩阵中的位置（下标i,j的值）：

$$i = \frac{k+1}{3} + 1 ， j = k - 2i + 3$$

###### 疑难解答

1. **对称矩阵是否是稀疏矩阵？**

>答：当n行n列的对称矩阵中非0元素的个数t远远小于 $n^2$ 时，对称矩阵也是稀疏矩阵。三对角矩阵是稀疏矩阵。

2. **计算对称矩阵在压缩数组中的存放位置时要注意什么问题？**

>答：要注意：矩阵是按上三角还是下三角存放；是按照行优先还是列优先存储；数组元素的下标从0开始还是从1开始；按下三角存放时是否 $i \geq j$ ，按上三角存放时是否 $i \leq j$ 。

3. **两个对称矩阵相加，结果是对称矩阵；两个对称矩阵相乘，结果还是对称矩阵吗？**

>答：两个对称矩阵相乘，结果可能不对称，除非这两个矩阵相同。

4. **两个三角矩阵相加，结果还是三角矩阵；两个三角矩阵相乘，结果还是三角矩阵吗？**

>答：两个三角矩阵相乘，结果不再是三角矩阵。

5. **为什么特殊矩阵极少使用链式存储？**

>答：因为要占据额外的存储空间且操作复杂。

6. **特殊矩阵在压缩存储后是否失去了随机存取的功能？**

>答：特殊矩阵在压缩存储后，并不影响随机存取的功能。特殊矩阵压缩存储时，相对位置是按照其特点计算出来的。同样在还原是也可根据其在存储数组中的位置算出在原有特殊矩阵中对应的位置，它仍然满足随机存取的特点。

##### 稀疏矩阵

###### 稀疏矩阵的相关概念与运算

1. **稀疏矩阵的定义**：一个矩阵中非0元素的个数远远小于矩阵元素的总个数，则称该矩阵为稀疏矩阵。在实际应用中，稀疏矩阵一般比较大，而非0元素一般比较少。

2. **稀疏矩阵的存储**：

    - **二维数组存储**：跟一般矩阵一样，采用二维数组来存储稀疏矩阵。优点是可以随机访问每一个元素，容易实现诸如加减法，乘除法，转置等运算。缺点是浪费大量空间来存放0元素，计算时花费大量时间来处理0元素的无效计算。

    - **三元组表存储**：矩阵中的每个非0元素可用该元素的行号i，列号j及元素值 $a_{ij}$ 来组成三元组 $(i , i , a_{ij})$ 来表示。若将所有的三元组按行号为主序，列号为辅序（行号相同时再考虑列号）进行排序，则构成一个表示稀疏矩阵的三元组表。

3. **稀疏矩阵的顺存储**：

    - 稀疏矩阵的三元组结构定义如下：

```C++
typedef int ElementType;

struct Triple{
    int row;
    int col;
    ElementType value;
};
```
    - 稀疏矩阵的顺序存储类型定义如下：

```C++
const int MAX_SIZE = 100;

struct SparseMatrix{
    int rows;
    int cols;
    int terms;
    Triple elem[MAX_SIZE];
};

```

4. **稀疏矩阵的链式存储**：

稀疏矩阵的链式存储采用十字链表表示，它为每个非0元素结点附带了两个指针：一个表示同一行下一非0元素结点（行指针），另一个指示同一行下一非0元素结点（列指针）。在十字链表中，每一个三元结点按矩阵元素所在行号i和列号j,链接在第i个行链表和第j个列来链表中，即处于所在的行链表和列链表的交汇处。

5. **稀疏矩阵的运算**：

- 稀疏矩阵的三元组表表示的缺点是失去了矩阵随机存取的特性；

- 稀疏矩阵的转置运算可以设计两个辅助表格，通过一遍扫描三元组表，预先统计原矩阵中各列非0元素的个数，预置转置后矩阵各行非0元素在三元组表中的位置。

- 稀疏矩阵的加法可以设计一个辅助向量，在逐行做加法时存放一行相加的结果，再压缩存放到结果三元组表中。结果保存仍继续保存回三元组表是因为可能出现新的非0元素。

- 稀疏矩阵相乘同样可以设计一个辅助向量，在逐行做乘法时，用于累加相乘结果，最后再压缩存入结果三元组表。

###### 疑难解答

1. **为什么稀疏矩阵的三元组表结构失去了直接存取特性，只能顺序存放？**

>答：对于稀疏矩阵的三元组表，只能按“行号”和“列号”顺序查找，以存取需要的数据元素的值，不能直接存取。

2. **两个稀疏矩阵相加，结果是稀疏矩阵（0元素的个数可能会有变化）；两个稀疏矩阵相乘，结果还是稀疏矩阵吗？**

>答：两个稀疏矩阵相乘，结果不一定是稀疏矩阵。

3. **采用带行指针的二元组表，相对于三元组表，有什么优点？**

>答：采用带行指针的二元组表，可以直接找到某行，且消除了三元组表中冗余的行号。在二元组表内搜索某列元素还需顺序擦查找，但个数少得多。

4. **为加快稀疏矩阵转置，相加和相乘的速度，一般设置哪两个数组？**

>答：一个存储目标矩阵的每行（或列）的非零元素个数，一个设定目标矩阵各行（或列）的开始存放地址。

---

### 字符串

#### 字符串相关概念

1. **字符串的定义**：字符串是由0各或多个字符的顺序排列所组成的线性序列，其基本组成元素是单个的字符（char），字符串的长度可变。

2. **串值和串名**：串值是可以直接引用的串，一般用一对''号或""作为分界符括起来。串名包括串变量名或串常量名，可以将字符串赋值给它，此后可以使用串名来使用串。

3. **串长度**：串长度是指串中字符的个数。长度等于0为空串。C/C++语言中字符串末尾的'\0'表示字符串结束符，不计入串长度。

4. **子串**：若一个字符串不为空，从该字符串中任意取出一段字符串称为该字符串的子串。

5. **前缀子串**：从字符串的开始第一个字符开始，连续取出若干个字符组成的字符串称为该字符串的前缀子串。

6. **后缀字串**：从字符串的某一位置开始到该字符串结束位置的连续字符构成的字符串称为该字符串的后缀字串。

7。 **串的模式匹配**：求子串在串中的位置的运算叫做串的连续模式匹配。

---

#### 字符串的初始化和赋值

1. 在C语言中，字符串是通过一维字符（char）数组来存放的，以字符'\0'来作为字符串结束的标记。因此，字符串也可以被看作是以字符'\0'结束的一维字符数组。

2. 在赋值时，字符串的串值不能赋值给字符串名。也就是若使用字符数组来存放字符串，则数组中某个位置的字符不能直接赋值给该数组名（串名），而只能赋值给字符（char）型变量。

3. 在使用字符数组来表示字符串时，定义的字符数组的长度不仅要满足字符串的长度，还要额外多一位来存放字符串结束的标志符'\0'。 char s\[6] = "hello!" 是有问题的。

4. C语言中，字符数组不能直接整体赋值，只能通过循环，依次将每个字符赋值给新的字符串，最后还得加'\0'字符表示字符串结束。

5. 可以使用指针来指向字符串，此时指针实际上保存的是字符串串值的首地址。

---

#### 自定义字符串

使用C语言的字符类型通过一维数组定义和使用字符串往往不太方便。因此，可以将字符串定义为一种新的数据类型，并在其上实现相关操作，从而简化字符串的使用。实际上，在绝大多数高级语言中，字符串往往被定义为一种新的类（类型），方便程序设计人员使用。

##### 字符串的存储表示

1. **定长顺序存储表示**：这种方式构成的字符串也被称为顺序串，是一种使用一组地址连续的存储单元来存储字符串中的字符的序列，通常使用定长一维字符数组来实现。这种方式实现简单，缺点也很明显，一旦分配的空间被用完，就不能再扩展，也就是所存储的的字符串的最大长度是固定的。

2. **堆分配存储表示**：与定长顺序分配不类似，堆分配存储方式也是借助一维字符数组来存放字符串字符。但字符数组是通过指针动态分配的，当分配的字符串数组不满足当前字符串存储所需的空间大小时，可以对字符数组进行扩容。扩容过程需要重新分配空间，若有需要还需将原本存入的字符串再移动到新分配的字符数组中，因此往往时间开销比较大。

3. **字符串的块链存储表示：** 理论上可以使用单链表来存放字符串字符，但使用传统单链表，单链表的每个结点都放一个字符，这样每个结点数据域所占空间比指针域所占的空间小的多，因此，存储密度太小。为了提高存储密度，每个结点的数据域往往不是存放一个字符，而实一个字符数组。可以认为链表的每个结点都存放一个该字符串的连续子串。由于这种方式可以看作是将字符串连续分为长度大小相同的若干块，每块按顺序存放在单链表中，因此称作块链存储。另外，每个结点存放的字符串长度都相同，且大于或等于1.

- 上述三种存储方式存储利用率可以用存储密度来衡量：

$$存储密度 = \frac{该串的串值所占用的存储空间大小}{为该串分配的存储空间总大小}$$

串的块链存储表示中，结点大小为1（数据域存储子串的长度）时，操作方便，但存储密度小。而结点大小大于1时，存储密度高，但操作不方便。

---

#### 字符串的模式匹配

##### 字符串模式匹配的定义

- **字符串的模式匹配是指**：设两个字符串T和P，若打算在串T中查找是否有与串P相等的子串，则称串T为目标，串P为模式，称查找模式串在目标串中的匹配位置的运算称为字符串的模式匹配。

##### 字符串模式匹配算法

1. **BF模式匹配**：BF模式匹配算法又称蛮力法或穷举的模式匹配，它的基本思路是：每趟顺序比对目标T与模式P中对应的字符，一旦发现不匹配，则将模式T右移，让模式P的开始位置与目标T的下一位置对齐，再从头用模式P中的字符与目标T中的字符顺序比对，这样一趟一趟比对下去，知道出现如下情况，匹配过程结束：

    - 若模式P中的每一位都与目标T对应字符比对相等，则匹配成功，算法返回模式P第０个字符在目标T中匹配的下标位置。

    - 若模式P与目标T对应字符比对不相等，目标T后面所剩字符个数少于模式P的长度，则匹配模式失败，算法返回-1；

2. **KMP模式匹配算法**：KMP算法又称无回溯的模式匹配算法。它的基本思路是：在第k趟比对时，若模式P的第j个字符与目标T的第i个字符比对失败，则在模式P前面0~j-1个字符的序列 $p_0p_1\cdots p_{j-1}$ 中寻找相等的最长前缀子串 $p_0p_1\cdots p_k$ 和后缀子串 $p_{j-k-1}p_{j-k}\cdots p_{j-1}$ 。若找到了这样的前缀子串和后缀字串，下一趟用模式P的第k+1各字符与目标T的上次匹配失败的位置i对齐，继续下一趟比对。若找不到这样的前缀子串和后缀字串，就从目标T匹配失败的位置i的下一位置起，让模式P的开始位置与之对齐，进行下一趟比对。最后对比结果有两种可能：

    - 若模式P中的所有字符都与目标T对应字符相等，则模式匹配成功。返回模式P在目标T中的位置。

    - 若模式P所有字符未比对完，目标T已检测完，则模式匹配失败，返回失败信息。

---

#### 疑难解答

1. **一个长度为n $（n \gt 0）$ 的串子串有多少个？**

>答：长度为n的子串有1各，长度为n-1的子串有两个，...... ，长度为1的子串有n个。因此，长度为n的串，子串共有： $1 +2 + 3 + \cdots + n = \frac{n(n + 1)}{2}$ 个。

2. **在做串的连接运算时，如果结果串的空间不够，应该如何处理？**

>答：这需要依据串存储的实现方式。若是定长顺序存储的顺序串，则只能保留长度等于存放前一个串的字符数组的长度的结果，剩下的只能被截断丢弃，或者返回错误信息。对于堆分配空间存储的字符串，由于其存储字符数组是动态分配的，当结果字符数组长度不够时，可以进行扩容，重新分配存储空间。对于采用链块存储的字符串，则完全不会出现这种问题，因为，链表是可以无限延长的。

3. **在做取子串的运算时，应考虑什么问题？**

>答：应考虑子串的在原字符串中的起始位置，子串的长度。同时要检验，给出的位置是否超出原字符串的长度。取出的子串长度与其实位置的和相加超过了原字符串的长度该怎么处理等。

4. **一个长度为n $(n \gt 0)$ 的串后缀子串有多少个？**

>答：后缀字串有n个。

5. **如何做两个串比较？**

>答：可以根据两个字符串中字符的ASIIC码值比较。当两个字符串长度不同时，长度长的比较大。若长度相同，则先比较两个字符串的第一个字符的ASIIC值，值大的比较大。如果相同，则比较第二个字符，以此类推。若最后每个字符都一样，则返回相等。

---

#### 字符串相关算法

1. 设计一个算法，统计字符串中各个不同字符出现的频度。

**C++语言编程实现**：

```C++
//设计一个算法，统计字符串中各个不同字符出现的频度。
void GetFrequency(string str, char ch[], int freq[], int &k)
{
    if (str.length() == 0)
        return;
    ch[0] = str[0];
    freq[0] = 1;
    int tmp = 1;
    for (int i = 1; i < str.length(); i++)
    {
        ch[i] = 0;
    }
    for (int i = 0; i < str.length(); i++)
    {
        for (int j = 0; j < tmp && ch[j] != str[i]; j++)
        {
            if (j == tmp)
            {
                ch[tmp] = str[i];
                ch[tmp]++;
                tmp++;
            }
            else
                ch[j]++;
        }
    }
}
```

2. 所谓回文串，是指从前往后读和从后往前倒着都都一样的不含空白字符的字符串。设计一个算法，判断一个字符串是不是回文串。

**C++语言编程实现**：

```C++
/*所谓回文串，是指从前往后读和从后往前倒着都都一样的不含空白字符的
    字符串。设计一个算法，判断一个字符串是不是回文串。*/
bool IsPalindrome(string str)
{
    int i = 0;
    int j = str.length() - 1;
    while (i < j)
    {
        if (str[i] != str[j])
            return false;
        else
        {
            i++;
            j--;
        }
    }
    return true;
}
```

3. 设计一个递归算法，将整数字符串转换为整数。

**C++语言编程实现**：

```C++
//设计一个递归算法，将整数字符串转换为整数。
int ConvertToNumber(string str, int start, int finish)
{
    if (start > finish)
        return -1;
    if (start == finish)
        return str[finish] - '0';
    return ConvertToNumber(str, start, finish - 1) * 10 + str[finish] - '0';
}
```

4. 设有两个字符串A，B。设计一个算法，找出A中第一个不在B中出现的字符。

**C++语言编程实现**：

```C++
//设有两个字符串A，B。设计一个算法，找出A中第一个不在B中出现的字符。
bool AFindFistCharWithoutAppear(string str1, string str2, char &ch)
{
    bool flag = true;
    int i;
    for (i = 0; i < str1.length(); i++)
    {
        flag = true;
        for (int j = 0; j < str2.length(); j++)
        {
            if (str1[i] == str2[j])
            {
                flag = false;
                break;
            }
        }
    }
    if (flag)
    {
        ch = str1[i];
    }
    return flag;
}
```

---

### 广义表

#### 广义表的概念与特性：

1. **广义表的概念**：广义表是指n $n(n \geq 0)$ 个表元素组成的有限序列。

    - 广义表可以表示为：$L = (e_1,e_2,\cdots,e_n)$ 。其中L为表名，$e_i(i = 1,2,\cdots, n)$ 是表元素，n是表长。n = 0 表示表为空 $n \neq 0$ 表示非空表。

    - 广义表的表元素可以是单元素，即不可再分的原子；也可以是广义表，称为广义表的子表。因此广义表的定义是递归的。
    
2. **广义表的特性**：

    - **有次序**：广义表的表元素的排列次序不能随意交换。

    - **有层次**：广义表的表元素可以是子表，子表还可以有子表。

    - **有深度**：最大嵌套层次数即为广义表的深度，用括号重数来识别。

    - **可共享**：广义表的子表可为多个广义表的子表。

    - **可递归**：广义表的子表可以是自身。

---

#### 广义表的表头和表尾

1. **表头**：广义表的第一个表元素即为广义表的表头，它可以是单元素，也可以是子表。

2. **表尾**：广义表除第一个元素外，其余元素组成的表称为广义表的表尾，它一定是广义表。

3. **空表无表头和表尾**。

---

#### 广义表的链式存储表示

1. 广义表的表元素都是单元素时，广义表退化为线性表，它的链式存储为单链表。

2. 一般情况下，广义表的链式存储为双链表。

    1. **头尾表示法**：双链表有两种结点：一种是表结点，代表广义表或子表，它的hlink指向表头，tlink指向表尾。另一种是原子结点，用来存储数据。

    2. **扩展线性链表表示法**：不区分表头和表尾，同样有两种结点，tlink指向它所代表的广义表或子表的第一个元素结点，tlink指向下一层下一个表元素结点。

    3. **广义表带头结点的层次表示法**：带头结点的层次表示法有三种结点：第一种是原子结点，存放指向子表结点的指针hlink和指向同一层下一元素的指针tlink；第二种是子表结点，存放指向子表头结点的指针hlink和指向同一层下一元素结点的指针tlink；第三种是头结点，标志广义表，存放表名和指向该表第一个元素结点的指针tlink。

---

#### 疑难解答

1. **广义表是线性表吗？**

>答：广义表是线性表的扩展。它的表元素都是原子时就是线性表。但如果表元素有原子结点，就不是线性表。广义表属于线性结构，它有表头也有表尾，每个表元素最多有一个直接前驱和一个直接后继。

2. **广义表为何要区分表头和表尾？**

>答：广义表定义是递归的，意味着它有多种递归实现。表头是递归算法中当前处理额部分，表尾是表头处理好之后需要处理的部分。这往往需要先向表头方向递归，再向表尾方向递归。

3. **是否意味着广义表是二叉树？**

>答：广义表虽然有层次结构，但不是树结构，因为广义表下层元可能有共享的结点。

4. **为何广义表中表元素的次序不能随意改变？**

>答：广义表元素的次序改变意味着将来处理的次序的改变，因此不能随意改变广义表表元素的次序。

5. **原子的深度是多少？空表的深度是多少？非空表的深度是多少？**

>答：原子的深度为0。空表的深度为1。非空表的深度要看他每个表元素的深度，取所有表元素深度最大值再加1就是非空表的深度。

6. **为处理共享情况，应对广义表的存储表示做如何修改？**

>答：对于使用头尾存储和扩展线性链表表示的广义表，为处理共享情形，可以再每个结点中增加一个标志域，若该结点被访问过，则标志为1，否则为0.对于带头结点的层次表示的广义表，只需把头结点中表名域改为访问计数域即可。

7. **如果广义表中出现自己定义的递归情况，这又意味着什么？**

>答：意味着是这是常规递归调用处理。在广义表的递归元素之前要定义原子元素，它是递归的结束条件。

---