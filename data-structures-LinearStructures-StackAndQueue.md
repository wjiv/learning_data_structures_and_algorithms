## 栈与队列

### 栈

#### 栈的定义和基本运算

1. **栈的定义**：栈（Stack）可以认为是只允许在末端进行插入和删除元素的线性表。

2. **栈的特点**：栈只允许在末端进行元素的访问，这里的末端有一个形象的名称——栈顶。也就是，栈只能在栈顶进行元素的插入和删除操作。由于栈的这种结构，往往先被插入到栈的元素要等到相较于该元素后被插入的元素退出栈，即该元素处于栈顶位置，才能被访问。因此，栈也被称作后进先出（LIFO,Last In First Out）或先进后出（FILO,First In Last Out）的线性表。

3. **栈的基本运算**：栈的基本操作（运算）有如下5种：

    - **栈初始化操作**：创建一个空的栈S并对其初始化；

    - **栈判空操作**：判断一个栈是否为空；

    - **进栈操作**：将元素压入栈内；

    - **出栈操作**：弹出栈顶元素；

    - **访问栈顶元素**：获取栈顶元素的值。

利用栈的这5种基本操作，可以实现基于栈的问题的求解。

---

#### 栈的混洗（Shuffle）

当一组序列通过入栈，出栈操作后，可能的出入栈序列跟这组元素的排列组合有关。当一组序列按照 $1,2,3,\cdots,n$的编号进栈时，可能的不同出栈序列数可以利用Catalan函数算出：

**$$\frac{1}{n+1}C^n_{2n} = \frac{1}{n+1} \times \frac{(2n)!}{n! \times n!} $$**

---

#### 栈的顺序存储结构

栈的顺序存储也称顺序栈。是指用一组地址连续的存储单元一次存放栈中的元素，并用top指着指向当前栈顶元素，当栈空时，top = -1。顺序栈往往借助数组来实现，可以使用静态或者动态方式来分配内存空间。

下面是顺序栈的编码实现：

**C++语言编程实现**：

```C++
#include <iostream>
using namespace std;

typedef int ElementType;
const int MAX_SIZE = 10;

#pragma region 顺序栈开始
//栈结构
struct Stack
{
private:
    ElementType *data;
    int top;

public:
    void init();                    //初始化栈
    void init(int size);            //初始化栈
    bool empty();                   //判断栈空
    bool full();                    //判断栈满
    bool push(ElementType element); //元素入栈
    bool pop(ElementType &element); //元素出栈
    ElementType getTop();           //获取栈顶元素
};

//初始化栈
void Stack::init()
{
    this->data = new ElementType[MAX_SIZE];
    this->top = -1;
}

//初始化栈
void Stack::init(int size)
{
    this->data = new ElementType[size];
    this->top = -1;
}

//判断栈是否为空
bool Stack::empty()
{
    return this->top == -1;
}

//判断栈是否已满
bool Stack::full()
{
    return this->top == sizeof(this->data);
}

//入栈操作
bool Stack::push(ElementType element)
{
    if (full())
        return false;
    this->top += 1;
    this->data[top] = element;
    return true;
}

//出栈操作
bool Stack::pop(ElementType &element)
{
    if (empty())
        return false;
    element = this->data[this->top];
    this->top -= 1;
    return true;
}

//获取栈顶元素
ElementType Stack::getTop()
{
    if (!empty())
        return this->data[this->top];
}

#pragma endregion 顺序栈结束

//main函数
int main(){
     //测试栈
    cout << "顺序栈测试：" << endl;
    cout << "声明一个顺序栈，将1，2，3，4，5五个元素依次入栈并出栈：" << endl;
    Stack sequenceStack;
    sequenceStack.init(5);
    sequenceStack.push(1);
    sequenceStack.push(2);
    sequenceStack.push(3);
    sequenceStack.push(4);
    sequenceStack.push(5);
    ElementType e;
    while (!sequenceStack.empty())
    {
        sequenceStack.pop(e);
        cout << e << " ";
    }
    cout << endl;
    return 0;
}
```

---

#### 栈的链式存储结构

栈的链式存储也称链栈。通常采用地址不连续的内存单元来存放栈中元素。实现方式与单链表类似，不同在于链式栈的实现一般不要头结点。链表的表头指针即为链栈的栈顶指针。

下面是链栈的编码实现：

**C++语言编程实现**：

```C++
#include <iostream>
using namespace std;

typedef int ElementType;
const int MAX_SIZE = 10;

#pragma region 链栈开始

//链式栈结点结构
struct LinkStackNode
{
    ElementType data;    
    LinkStackNode *link; 
};

//链式栈结构
struct LinkStack
{
private:
    LinkStackNode *top; //栈顶指针

public:
    void init();                    //初始化栈
    bool empty();                   //判断栈是否为空
    bool push(ElementType element); //入栈操作
    bool pop(ElementType &element); //出栈操作
    ElementType getTop();           //获取栈顶元素
};

//初始化栈
void LinkStack::init()
{
    this->top = new LinkStackNode;
    this->top->link = nullptr;
}

//判断栈是否为空
bool LinkStack::empty()
{
    return this->top->link == nullptr || top->link == NULL;
}

//入栈操作
bool LinkStack::push(ElementType element)
{
    LinkStackNode *node = new LinkStackNode;
    node->data = element;
    node->link = this->top->link;
    this->top->link = node;
    return true;
}

//出栈操作
bool LinkStack::pop(ElementType &element)
{
    if (empty())
        return false;
    element = this->top->link->data;
    LinkStackNode *node = this->top->link;
    this->top->link = node->link;
    delete node;
    return true;
}

//获取栈顶元素
ElementType LinkStack::getTop()
{
    if (!empty())
        return this->top->link->data;
}

#pragma endregion 链栈结束

//main函数
int main(){
    cout << "链式栈测试：" << endl;
    cout << "声明一个链式栈，将6，7，8，9，10五个元素依次入栈并出栈：" << endl;
    LinkStack linkStack;
    linkStack.init();
    linkStack.push(6);
    linkStack.push(7);
    linkStack.push(8);
    linkStack.push(9);
    linkStack.push(10);
    while (!linkStack.empty())
    {
        linkStack.pop(e);
        cout << e << " ";
    }
    cout << endl;
    return 0;
}
```

---

#### 疑难解答

1. **理解栈的存储结构的要点。**

>答：
    (1). 顺序栈的操作一般在栈顶指针处进行。在顺序栈的实现中，初始化函数多用于为栈赋初值，令top = -1，置栈空。
    (2). 在实现进栈操作时，首先要判断栈是否已满。若 top = MAX_SIZE - 1，则说明栈满。
    (3). 在进行出栈操作时，首先要判断栈是否为空。即top是否等于-1。如栈空，则不执行出栈操作。
    (4). 链栈的栈顶在链表的表头。一般实现链栈的链表不含头结点。链表的插入删除操作都在表头进行，表头即栈顶。另外也不需要记录链表尾指针。
    (5). 在不能预知栈的大小时，一般采用链式栈作为栈的存储方式更合适。

2. **栈是一种先进后出的顺序存取结构，它是顺序存储结构吗？**

>答：顺序存取跟顺序存储是两个不同的概念。顺序存取是指，只能逐个存取或者访问结构中的元素。而顺序存储是指元素在实际物理空间中的存放是连续的，即物理存储地址是连续的。栈只能在栈顶进行顺序存取，而栈的实现可以是基于数组的顺序存储方式或者基于链表的链式存储方式。

3. **一个较早进栈的元素能否先于在它之后进栈的元素从栈中取出？**

>答：若，该元素被压入栈中，后面的元素也被压入栈中，且在该元素额顶部，则该元素不能先于在它之后进栈的元素从栈中取出。若该元素后面的元素还未入栈，则该元素可以直接从栈顶取出。

4. **一般来讲，只允许栈顶元素从栈中退出，在什么情况下元素可以从栈底泄出？**

>答：操作系统的调度算法设计中，可以允许元素从栈底泄出。

5. **以1，2，3，...，n的顺序进栈，如何判断可能的出栈序列？**

>答：可以使用Catalan函数来求解。

6. **当一个顺序栈已满，如何才能扩充栈长度，使得程序能够继续使用这个栈？**

>答：顺序栈的扩充，只适用于基于动态分配数组存储空间的栈。可以分配一个空间较之前栈空间大一倍的空间来取代原来栈的存储空间。

7. **当两个栈共享同一存储空间V\[m]时，可设栈顶指针数组t\[2]和栈底指针数组b\[2]。如果进栈采用两个栈相向前行的方式，则任一栈的栈满条件是什么？**

>答：当两个栈栈顶指针碰面，即表达式：t\[0] + 1 == t\[1]为真时，表明栈满。

8. **顺序栈的优点是什么？缺点是什么？**

>答：顺序栈的优点是：存取速度快，实现简单。缺点是：顺序栈分配空间过大会造成空间浪费，分配过小，则容易发生栈满溢出。

9. **链式栈可否增加头结点？如果增设了头结点，链式栈的栈顶在链表的什么位置？栈底在链表的什么位置？栈指针如何设置？栈空的条件是什么？栈满的条件是什么？**

>答：链式栈可以增加头结点。若增加了头结点，则栈顶指针位置应该在头结点指针指向的结点。栈尾在链表的表尾。栈顶指针应设置在头结点处。每次进出栈操作都在头结点后进行。栈空的条件是头结点指针域为是否为空。无栈满条件。

10. **链式栈的优点是什么？缺点是什么？**

>答：链式栈的优点是：便于结点的插入和删除，无栈满条件，同一个程序中使用多个栈时，可以共享一个链式栈，不仅提高了效率，还能共享空间。缺点是：需要额外的存储空间来存储链表信息，比如指向下一个结点的指针。

11. **链式栈只能顺序存取，而顺序栈不但能顺序存取，还能直接存取，这种说法对吗？**

>答：不对。栈的特点决定它只能是一种顺序存储结构，无论顺序栈还是链式栈都不能直接存取元素，只能在栈顶对元素进行存取操作。

12. **理论上链式栈没有栈满问题，但在进栈时还有一个后置条件，是什么？**

>答：该后置条件应该为判断动态申请栈结点存储空间是否成功。当栈结点存储空间分配成功时，才能进行入栈操作，否则应该报告分配空间失败的相关信息。

---

#### 栈相关算法

1. 改写顺序栈的进栈成员函数push(x)，要求当栈满时，执行一个stackFull()操作进行溢出处理。其功能是：动态创建一个比原来的栈数组大一倍的新数组，代替原来的栈数组，原来栈数组中的元素占据新数组的前maxSize个位置。

**C++语言编程实现**：

```C++

```

2. 借助栈实现单链表上的逆置运算。

**C++语言编程实现**：

```C++

```

3. 设一个栈的输入序列是：1，2，3，...，n。设计一个算法，判断一个序列：$p_1，p_2，\cdots ，p_n$ 是否是一个合理的栈输出序列。

**C++语言编程实现**：

```C++

```

---

### 队列

#### 队列的定义和基本运算

1. **队列的定义**：队列（queue）是一种限定存取位置的线性表。

2. **队列的特点**：队列允许只能在表的一端进行插入，而在另一端进行删除。通常插入的一端被称为队尾（rear），删除的一端被称为队头（front）。由于队列一端只能进行插入（也称入队），另一端只能进行删除（也称出队），因此，最早从队尾进入队列的元素，必最先从队头出来。因此，队列也称先进先出（FIFO,First In First Out）的线性表。

3. **队列的基本运算**：队列的基本（运算）操作包含如下5种：

    - **队列初始化操作**：创建一个空的队列Q并初始化；

    - **队列判空操作**：判断队列是否为空队列；

    - **入队操作**：当队列未满时，将元素插入队尾；

    - **出队操作**：当队列为空时，移除队头元素；

    - **访问队头元素操作**：获取队头元素的值。

---

#### 队列的顺序存储结构

队列的顺序存储也称顺序队列。它是利用一组地址连续的存储空间来存放队列元素，通常借用数组来实现。并且设置队头指针front与队尾指针rear分别指向队列的队头跟队尾。

1. **循环队列**：普通顺序存储的队列可由一维数组来实现。当队列为空时，队头指针front与队尾指针rear满足front = rear = -1。每当有元素入队后，rear的值增加1；有元素出队时，front的值增加1。当队满时，不能再进行入队操作，假设此时有n个元素退出了队列，而实际上在实现队列的数组中下标为0~n-1的位置缺空了下来（实际上是不属于队列，出队操作往往修改的是队头指针的指向位置，原本数组中存在的元素不一定被删除覆盖），这种现象也成为假溢出——当队列满时，实际上分配的数组空间还有位置可以存放元素。“假溢出”势必会造成存储空间的浪费。为了解决这个问题，引入了循环队列。

**循环队列**是指：当顺序队列队尾指针指向存储数组的最后一个元素时，再进行入队操作，若该队列有元素出队，造成存储数组前面的位置空了下来，则将入队元素从数组的0号下标位置依次继续插入队列。这样整个队列看起来就像一个环。故称作循环队列。对于循环队列，若队满之后，每次有一个元素出队的同时有一个元素入队，则该循环队列可以进行无限次这样的操作。

2. **循环队列判空跟判断队满**：在普通的顺序队列中，当rear值等于分配数组的长度减一时，表示队列已满，当front=rear时表示队列为空。而对于一个可以存放n个元素的数组，将其作为循环队列的实现结构，则front=rear时，可以认为队列为空，也可以认为该队列已经放入了n个元素。因此，front==rear不能作为循环队列判空的条件。为了区分循环队列是否为空或者是否为满队，常用的方法有三种：

- **牺牲一个存储空间。** 即队列中只存放**n-1**个元素，此时**front == rear**仍可作为队空的判断条件，而判断队满的条件则是：**(rear + 1) % n == front**。

- **增加计数器。** 即在队列结构中增加一个计数器，每**入队**一个元素，该计数器加一，每**出队**一个元素，计数器减一。该计数器也可称为队长，或者队列的容量（大小）。这样，当 **front == rear** 条件为真时，判断计数器的大小，若计数器等于0，则表示队空，若计数器等于分配的数组的长度，则表示队满。

- **标记法。** 所谓标记法，就是在队列结构中增加一个标记tag，并在队列中有元素时保证tag=1，无元素时保证tag=0。这样 **front == rear && tag = 0** 为真时，表示循环队列为空。**front == rear && tag = 1** 为真时表示队列已满。

3. **顺序队列的实现：**

**C++语言编码实现**：

```C++

```

---

#### 队列的链式存储结构

队列的链式存储也成为链式队列。是采用链表来作为队列元素存储的实现方式。队列的链式存储一般借助单链表或者单循环链表来实现。

1. **采用单链表实现队列**：基于单链表实现队列，链表结点结构即为单链表的链表结构。与单链表的不同是，需要指定队头指针front与队尾指针rear。一般带头结点的单链表，头结点位置即为队头指针位置，队尾指针指向尾结点。不带头结点的单链表，单链表表头指针位置即为队头指针。队尾指针仍在链表尾。

2. **采用单循环链表实现队列**：基于单循环链表的链式队列实现，结构上与单循环链表类似。基于单循环链表的链式队列只需要指定队尾指针rear。由于链表表尾通过指针又指向链表表头，因此，当进行入队操作时，在rear后面增加结点。而出队操作，实际上也是删除rear后面的结点。这种方式实现的链式队列，入队跟出队操作时间复杂度都是O(1)。

3. **链式队列的实现**：

**C++语言编码实现**：

```C++

```

---

#### 疑难解答

1. **理解队列的要点**

>答：
    (1). 出队操作会删除队头的元素，而访问队头操作只是获取队头元素的值，实际元素还在队列当中；
    (2). 当一组元素按一定顺序一次进入队列，出队序列仍与原序列一致。即无论其入队和出队操作如何组合，最后输出的元素次序与入队时相同；
    (3). 当一组元素以1,2,3,...,n编号进入队列后，可能的出队序列只有一种，仍是：1,2,3,...,n；
    (4). 初始化时，令front = rear = 0，则置空队列；
    (5). 每次入队，先将元素插入，再移动队尾指针，出队也一样，先保存队头元素，再移动队头指针；
    (6). 每次从队头退出一个元素时，需要先判断队列是否为空，入队时，如果是顺序队列，则需要判断队列是否已满；

2. **队列具有先进先出的特性，可不可以加塞，在队列其他位置进出队列？**

>答：不能。队列是限制了存取位置的线性结构。若允许在其他任意位置进出队列，便不能再称之为队列，而是成为普通的线性表了。

3. **以1，2，3，...，n进队，可能的出队序列有多少种？**

>答：可能的出队序列只有一种，与入队时一致，仍是：1，2，3，...，n。

4. **栈，队列和向量（一维数组）有什么不同？**

>答：最大的区别在于，向量可以直接（随机）存取，而栈跟队列只能在指定位置顺序存取。其中栈约定只能在栈顶进行元素的存取，而队列只能在队头出队，队尾入队。

5. **在循环队列中进行插入和删除时，是否需要移动队列元素的位置？**

>答：在循环队列中进行插入和删除时，不需要比较和移动队列任何元素，只需要修改队头指针front和队尾指针rear，并向队尾插入元素或从队头取出元素。

6. **可否在链式队列中增加头结点？此时链式队列的队头和队尾在链表的什么地方？对空的条件是什么？**

>答：可以在链式队列中增加头结点，此时队头在链表的头结点处，队尾在链表的队尾处。队空的条件是队列链表头结点指针域为空。

7. **同时使用多个队列时需采用何种队列结构？如何组织？**

>答：同时使用多个队列时应采用链式队列结构。入队，出队，判空等操作与一般队列相同。

8. **链式队列的每个结点是否还可以是队列？**

>答： 可以。队列是一种限定了元素存取位置的线性表，按照一般线性表的定义，每个线性表元素应为不再分的数据元素。但处于实际应用额需要，链式队列的每个结点仍可以是一个队列。

---

#### 队列相关算法

1. 改进采用用一维数组存储元素的循环队列的入队函数。当队列满并需要插入新元素时将数组空间扩大一倍，使得新元素得以插入。

**C++语言编码实现**：

```C++
```

2. 改进采用用一维数组存储元素的循环队列的出队函数。当队列元素少于数组空间的1/4时将数组空间自动缩小一半。

**C++语言编码实现**：

```C++
```

---

### 栈的应用

#### 栈在表达式求值中的应用

1. **中缀表达式**：

2. **后缀表达式**：

#### 栈在递归中的应用

#### 疑难解答

#### 栈的应用相关算法

### 队列的应用

#### 逐层处理

#### “先来先服务”调度策略

#### 数和二叉树搜索策略

#### 图或网格中广度优先搜索策略

#### 疑难解答

#### 队列应用相关算法

### 双端队列

#### 双端队列的概念

#### 输入受限的双端队列

#### 输出受限的双端队列

#### 疑难解答

#### 双端队列相关算法